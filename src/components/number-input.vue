<template>
    <div class="number-input">
        <label v-if="label != null && label.trim() !== ''">{{ label }}</label>

        <div
            class="content"
            ref="input"
            tabindex="0"
            contenteditable="true"
            v-html="internalValue"
            :disabled="disabled"
            :min="min"
            :max="max"
            @keydown="onKeydownEvent($event)"
            @keyup="validateInput($event)"
            @blur="defaultValueOnBlur($event)"
        ></div>
    </div>
</template>

<script lang="ts">
import { Component, Vue, Prop, Model, Watch } from 'vue-property-decorator';

import { convertToBoolean } from '../utils/converters';

@Component({ name: 'spl-number-input' })
export default class NumberInputComponent extends Vue {
    @Model('change', { type: [Number, String] })
    public value: string | number;

    @Prop({ type: Number })
    public min: number;

    @Prop({ type: Number })
    public max: number;

    @Prop({ type: Boolean })
    public decimals: boolean;

    @Prop({ type: Boolean })
    public disabled: boolean;

    @Prop({ type: String })
    public label: string;

    /**
     * Internal value to prevent Prop-Mutations
     */
    public internalValue = 0;

    /**
     * Internal Disabled-State to prevent Prop-Mutations
     */
    public internalDisabled: boolean = false;

    /**
     * If the user should be able to enter decimal values
     */
    public internalDecimal: boolean = false;

    /**
     * If increasing the value is currently allowed/possible
     */
    public enableUp = true;

    /**
     * If decreasing the value is currently allowed/possible
     */
    public enableDown = true;

    public readonly flatRegex = /^[+-]?([\d])*$/;
    public readonly decimalRegex = /^[+-]?([\d])*(\.[\d])?$/;

    private oldRange: Range;

    validateInput(event: KeyboardEvent) {
        this.updateContent((event.target as HTMLElement).innerHTML);
    }

    onKeydownEvent(event: KeyboardEvent) {
        this.oldRange = window.getSelection().getRangeAt(0);
    }

    recoverSelection() {
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(this.oldRange);
    }

    defaultValueOnBlur(event: any) {
        const value = event.target.value;
        if (value === '') {
            event.target.value = 0;
        }
    }

    up() {
        if (!this.enableUp) {
            return;
        }
        (this.$refs.input as any).focus();
        this.internalValue++;
        this.updateContent();
    }

    down() {
        if (!this.enableDown) {
            return;
        }
        (this.$refs.input as any).focus();
        this.internalValue--;
        this.updateContent();
    }

    updateContent(str?: string) {
        if (str == null) {
            str = `${this.internalValue}`;
        }

        let newValue = 0;
        if (this.decimals) {
            newValue = parseFloat(str);
        } else if (!this.decimals) {
            newValue = parseInt(str, 10);
        }

        if (isNaN(newValue) ||!isFinite(newValue)) {
            this.recoverSelection();
            (this.$refs.input as any).innerHTML = this.internalValue;

            return;
        }

        if (typeof this.max === 'number' && newValue > this.max) {
            newValue = this.max;
            this.enableUp = false;
        } else {
            this.enableUp = true;
        }

        if (typeof this.min === 'number' && newValue < this.min) {
            newValue = this.min;
            this.enableDown = false;
        } else {
            this.enableDown = true;
        }

        const hasValueChanged = this.internalValue !== newValue;
        if (hasValueChanged || `${newValue}` !== str) {
            this.internalValue = newValue;
            if (hasValueChanged) {
                (this.$refs.input as any).innerHTML = newValue;
            }
            this.$emit('change', newValue);
        }
    }

    @Watch('value', { immediate: true })
    onValuePropChange(val, old) {
        if (val === old) {
            return;
        }
        this.internalValue = val;
        this.updateContent();
    }

    @Watch('disabled', { immediate: true })
    onDisabledPropChange(value) {
        this.internalDisabled = convertToBoolean(value);
    }

    @Watch('min', { immediate: true })
    onMinPropChange(val, old) {
        if (typeof this.max === 'number' && val > this.max) {
            throw new RangeError(
                'The minimal amount cannot be higher than the maximal!'
            );
        }
        if (val === old) {
            return;
        }
        this.updateContent();
    }

    @Watch('max', { immediate: true })
    onMaxPropChange(val, old) {
        if (typeof this.min === 'number' && val < this.min) {
            throw new RangeError(
                'The maximal amount cannot be lower than the minimal!'
            );
        }
        if (val === old) {
            return;
        }
        this.updateContent();
    }
}
</script>

<style lang="scss" scoped>
@import '../styles/config';

.number-input {
    width: 100%;
    box-sizing: content-box;

    label {
        display: block;
        flex: none;
        font-size: 10px;
    }

    .content {
        width: 100%;
        border: 1px solid $spl-color-off-black;
        background: $spl-color-off-black;
        color: $spl-color-off-white;
        padding: 6px 13px;
        transition: 200ms;

        &::-webkit-outer-spin-button,
        &::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        &.outline {
            border-color: $spl-color-dark-gray;
        }

        &:focus {
            outline: none;
            border-color: $spl-color-primary;
        }
    }
}
</style>
